% \part{Temes avançats}
% \label{part:avançats}

% https://books.google.es/books?id=pWlbvW0H3IAC&pg=PA274&lpg=PA274&dq=embedded+programming+models&source=bl&ots=vQxIpc23Pp&sig=c5q9zBbwd7on7V2E_awwZ54rHpg&hl=ca&sa=X&ved=2ahUKEwjl6KCgopbfAhUNXRUIHferAIcQ6AEwCHoECAUQAQ#v=onepage&q=embedded%20programming%20models&f=false

% https://www.nap.edu/read/10193/chapter/7
% https://www.embedded.com/design/debug-and-optimization/4006502/Back-to-the-basics-Picking-the-right-computational-model

% https://courses.cs.washington.edu/courses/cse466/02au/Lectures/State-models.pdf
%% FSM, FSMD, HCFSM, Program-state machine model (PSM), Dataflow, 02auSynchronous dataflow, 

Fins ara hem vist com controlar els perifèrics més habituals que poden trobar a un microcontrolador, fent ús de les biblioteques dels fabricants. També hem vist els conceptes que hi ha al darrera d'un RTOS, amb els seus canals de comunicació i sincronització entre tasques, etc.

\chapter{Polling d'esdeveniments}
El primer model de programació i potser el més senzill és el d'un bucle infinit que està en una espera activa ({\em polling}) de certs esdeveniments per actuar com calgui segons l'aplicació. En aquest model no es fan servir les interrupcions i en tot moment es prova de fer la lectura dels perifèrics o sensors que han de permetre una lectura nova i potser provocar un canvi en el sistema. Per tant, aquest model consistirà bàsicament en un bucle infinit dins la funció {\em main} de l'aplicació. Aquest bucle anirà repetint indefinidament les lectures necessàries i les actuacions pertinents si s'han pogut fer.

Un exemple d'aquesta mena d'estil de programació s'ha vist a \fullref{ch:aplicaciosenzilla}, on l'aplicació ha de llegir un sensor de distància per mostrar-la en un LEDs controlant la seva potència. En aquest exemple, el codi conté una funció {\bf main} que hi ha un bucle infinit on contínuament es prova de llegir el valor de proximitat del sensor i, si és el cas, variar la lluminositat del LED segons la lectura feta (veure també el codi~\ref{ProximityExample}).

Aquesta mena de programació és suficient per múltiples aplicacions senzilles, on la lògica de l'aplicació depèn de poques variables o condicions i el concepte de {\em timeout} o de temps en general n'és absent. Si, per exemple, volem que transcorri algun temps entre algunes instruccions o esperar-se un determinat temps per realitzar una operació, caldrà introduir el temps al model.

% AIxò pot ser un subaparta?
\chapter{Mode seqüencial}
\lipsum

% AIxò pot ser un subaparta?
\chapter{Flux de dades}
\lipsum

% AIxò pot ser un subaparta?
\chapter{Bucle de control}
\label{ch:buclecontrol}

\lipsum

% AIxò pot ser un subaparta?
\chapter{Màquines d'estats finits}
\label{ch:maquinesstats}

\lipsum

\chapter{Control per interrupcions}
En aquest model, es codifica per tal de tenir el microcontrolador lliure en la major part del temps tot esperant a que una o vàries interrupcions facin saltar l'execució a la part de codi necessari. En aquest model és habitual configurar els perifèrics o dispositius per a que generin una interrupció quan necessitin certa atenció enlloc d'anar fent {\em polling} contínuament.





